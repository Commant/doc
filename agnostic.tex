Un autre particularité de l'extension vectorielle du RISC-V est sa gestion agnostique des registres vectoriels lors de la compilation. Ce comportement est aussi utilisé par SVE, son utilité est de former un exécutable mobile (pouvant être exécuté par un processeur différent du moment qu'il possède le même jeu d'instruction), mais cela provoque un gros défaut pour les programmeurs: la taille des registres vectoriels n'est pas accessible au moment de la compilation. Le seul moyen de l'obtenir est de l'appeler au moment de l'exécution, ce qui rend tout de suite la vie plus difficile pour les développeurs de librairies SIMD (Single Instruction Multiple Data).\\

La première raison à cela est la difficulté de manier un type de registre vectoriel. Comme la taille de l'objet n'est pas connue à la compilation, en C/C++, un tel type est considéré comme un \ti{sizeless struct}. Avec les versions actuelle des compilateurs, cette structure ne peut faire office d'attribut d'une classe ou d'une structure, et la notion d'adressage n'est absolument pas sécurisée car l'objet est physiquement situé au niveau du processeur et non de la RAM. Les seules actions réalisables sont l'utilisation en fonction (passage en argument, type de retour ou recours aux intrinsèques), ou le renommage du type avec un \tic{blue}{typedef}.\\
   
La deuxième raison concerne MIPP, qui est un wrapper, or, les wrapper ne peuvent pas stocker de variables. Il est donc impossible de récupérer la taille des registres vectoriel au début du programme pour ensuite la réutiliser.\\